#include "xparameters.h"
#include "xgpio.h"
#include "signal_ip.h"
/**************************** user definitions ********************************/
#define CHANNEL 1
//Cordic processor base addres redefinition
#define SIGNAL_BASE_ADDR_A XPAR_AXI_GPIO_A_BASEADDR
#define SIGNAL_BASE_ADDR_B XPAR_AXI_GPIO_B_BASEADDR
#define SIGNAL_BASE_ADDR_C XPAR_AXI_GPIO_C_BASEADDR
#define SIGNAL_BASE_ADDR_R XPAR_AXI_GPIO_R_BASEADDR
//Cordic processor registers' offset redefinition
#define CONTROL_REG_OFFSET SIGNAL_IP_S00_AXI_SLV_REG0_OFFSET
#define A_REG_OFFSET SIGNAL_IP_S00_AXI_SLV_REG1_OFFSET
#define STATUS_REG_OFFSET SIGNAL_IP_S00_AXI_SLV_REG2_OFFSET
#define RESULT_REG_OFFSET SIGNAL_IP_S00_AXI_SLV_REG3_OFFSET
#define B_REG_OFFSET SIGNAL_IP_S00_AXI_SLV_REG4_OFFSET
#define C_REG_OFFSET SIGNAL_IP_S00_AXI_SLV_REG5_OFFSET
#define R_REG_OFFSET SIGNAL_IP_S00_AXI_SLV_REG6_OFFSET
#define RESULT_REG_RE(param) ((u32)param & (u32)(0x00000FFF))
#define RESULT_REG_IM(param) (((u32)param & (u32)(0x0FFF0000)) >> 16 )

#define CLEAR_ONE NUBMERS_BITS | 1
#define CLEAR_ZERO NUBMERS_BITS
/***************************** Main function *********************************/
int main(){
int status;
XGpio AGpio, BGpio, CGpio, RGpio, ReGpio, ImGpio;
u32 data, data1, data2, data3;
u32 result, Re, Im;
/* Initialize driver for the input angle GPIOe */
status = XGpio_Initialize(&AGpio, XPAR_AXI_GPIO_A_DEVICE_ID);
if (status != XST_SUCCESS) {
goto FAILURE;
}
XGpio_SetDataDirection(&AGpio, CHANNEL, 0xFFF);
/* Initialize driver for the output sin GPIO */
status = XGpio_Initialize(&ReGpio, XPAR_AXI_GPIO_RE_DEVICE_ID);
if (status != XST_SUCCESS) {
goto FAILURE;
}
XGpio_SetDataDirection(&ReGpio, CHANNEL, 0x000);
/* Initialize driver for the output sin GPIO */
status = XGpio_Initialize(&ImGpio, XPAR_AXI_GPIO_IM_DEVICE_ID);
if (status != XST_SUCCESS) {
goto FAILURE;
}
XGpio_SetDataDirection(&ImGpio, CHANNEL, 0x000);
//Read angle binary data from angle GPIO. fxp(12:10) format
data = XGpio_DiscreteRead(&AGpio, CHANNEL);
data1 = XGpio_DiscreteRead(&BGpio, CHANNEL);
data2 = XGpio_DiscreteRead(&CGpio, CHANNEL);
data3 = XGpio_DiscreteRead(&RGpio, CHANNEL);
//Send data to data register of cordic processor.
//For the slv_regN register offset look into cordic driver header file: cordic_ip.h
SIGNAL_IP_mWriteReg(SIGNAL_BASE_ADDR_A, A_REG_OFFSET, data);
SIGNAL_IP_mWriteReg(SIGNAL_BASE_ADDR_B, B_REG_OFFSET, data1);
SIGNAL_IP_mWriteReg(SIGNAL_BASE_ADDR_C, C_REG_OFFSET, data2);
SIGNAL_IP_mWriteReg(SIGNAL_BASE_ADDR_R, R_REG_OFFSET, data3);

//Start cordic processor - pulse start bit in control register
SIGNAL_IP_mWriteReg(SIGNAL_BASE_ADDR_A, INFO_REG, NUBMERS_BITS | 2); // PRCOESS 1

SIGNAL_IP_mWriteReg(SIGNAL_BASE_ADDR_A, CONTROL_REG_OFFSET, 1);
SIGNAL_IP_mWriteReg(SIGNAL_BASE_ADDR_A, CONTROL_REG_OFFSET, 0);

//Wait for ready bit in status register
while( (SIGNAL_IP_mReadReg(SIGNAL_BASE_ADDR_A, STATUS_REG_OFFSET) & 0x01) == 0);
//Get results
result = SIGNAL_IP_mReadReg(SIGNAL_BASE_ADDR_A, RESULT_REG_OFFSET);
//Extract sin and cos from 32-bit register data
Re = RESULT_REG_RE( result );
Im = RESULT_REG_IM( result );
//Send to GPIO
XGpio_DiscreteWrite(&ReGpio, CHANNEL, Re);
XGpio_DiscreteWrite(&ImGpio, CHANNEL, Im);
/* Failure or end trap */
FAILURE:
while(1);
}

